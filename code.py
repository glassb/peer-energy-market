# -*- coding: utf-8 -*-
"""EC500-Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1InvHioQipbEuSXscVzqDYbZeOQwQ3coh
"""

# 4/10

'''
                node 0
                /   \
               /     \
          node 1    node 2
          /
         /
      node 3


'''

import numpy as np
from scipy import optimize as opt
from scipy import linalg as linearalgebra


'''
Decision Variables Index: [24 energy trades + 8 Battery vars]
[00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33 B0p B0e B1p B1e B2p B2e B3p B3e]


00 01 02 03
10 11 12 13
20 21 22 23
30 31 32 33
'''
#labels for printing output
decision_variables = ['00','01','02', '03', '10', '11', '12', '13', '20', '21' ,'22', '23', '30', '31', '32', '33', 'B0p', 'B0e', 'B1p', 'B1e', 'B2p', 'B2e', 'B3p', 'B3e']
timesteps = ['T1','T2','T3','T4']


#costs = np.tile([1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],4)

initial_guess = np.tile(np.zeros(24),4)

#we can set individual bounds for any of the decision variables
bounds = []


# ---------------------------------- f: POWER FLOW CONSTRAINTS

#Wbar matrix for 4 node system
Wbar = [[1,-1,0,0],
        [1,0,-1,0],
        [0,1,0,-1]]

#W matrix for 4 node system
W = [Wbar[0][1:],
    Wbar[1][1:],
    Wbar[2][1:]]

# linear transform to calculate f (convert energy trades to net nodal power injections at nodes 1->3)
nodal_power_transform = [[0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0]]

# block diagonalizing Wbar, W, and nodal_power_transform 4 times in order to account for 4 timesteps
nodal_power_transform_4_timesteps = linearalgebra.block_diag(nodal_power_transform,nodal_power_transform,nodal_power_transform,nodal_power_transform)
W_inv_T =np.transpose(np.linalg.inv(W))
W_inv_T_4_timesteps = linearalgebra.block_diag(W_inv_T,W_inv_T,W_inv_T,W_inv_T)

#calculate A matrix for constraint: lb <= Ax <= ub
f_matrix = np.matmul(W_inv_T_4_timesteps,nodal_power_transform_4_timesteps)

#upper/lower bounds
fmax = [10,10,10,10,10,10,10,10,10,10,10,10]
fmin = [0,0,0,0,0,0,0,0,0,0,0,0]

loads = [1000,1200,1100]

#Start each battery with 50kWh, all have the same hardware settings
batt_initial = [50, 50, 50, 50]
batt_min_e = [20, 20, 20, 20]
batt_max_e = [80, 80, 80, 80]
batt_min_p = [-10, -10, -10, -10]
batt_max_p = [10, 10, 10, 10]


# ---------------------------------- CONSTRAINTS

constraint = ({'type':'eq','fun': lambda x: sum(x) - sum(loads)}, # we need to parition this by timestep
              {'type':'eq','fun': lambda x: x[0]},
              {'type':'eq','fun': lambda x: x[5]},
              {'type':'eq','fun': lambda x: x[10]},
              {'type':'eq','fun': lambda x: x[15]},
              {'type':'eq','fun': lambda x: x[24]},
              {'type':'eq','fun': lambda x: x[29]},
              {'type':'eq','fun': lambda x: x[34]},
              {'type':'eq','fun': lambda x: x[39]},


              # (19d) constraints
              {'type':'ineq','fun': lambda x: fmax - np.matmul(f_matrix,x)},
              {'type':'ineq','fun': lambda x: np.multiply(-1,fmin) + np.matmul(f_matrix,x)},

              # (19e) constraints
              {'type':'eq','fun': lambda x: x[1]+x[5]},
              {'type':'eq','fun': lambda x: x[2]+x[8]},
              {'type':'eq','fun': lambda x: x[3]+x[12]},
              {'type':'eq','fun': lambda x: x[6]+x[9]},
              {'type':'eq','fun': lambda x: x[7]+x[13]},
              {'type':'eq','fun': lambda x: x[11]+x[14]},

              {'type':'eq','fun': lambda x: x[25]+x[29]}, #timestep 2
              {'type':'eq','fun': lambda x: x[26]+x[32]},
              {'type':'eq','fun': lambda x: x[27]+x[36]},
              {'type':'eq','fun': lambda x: x[30]+x[33]},
              {'type':'eq','fun': lambda x: x[31]+x[37]},
              {'type':'eq','fun': lambda x: x[35]+x[38]},

              #Battery Constraints - Also need battery power in power-flow constraints
              #Power Min
              #Power Max
              #Charge State Min
              #Charge State Max
              #Charge-State change after time iteration
              #Initial Charge State (at time zero, need to initialize battery charge
              #{'type':'eq','fun': lambda x: x[35]+x[38]}

              )


# cost function formulation: this can be quadratic or linear
'''
consumer charge is form ax^2 + bx where a and b are coefficients chosen by the consumer
To get in the cost function form we will see (x)T*A*x + bx where A a matrix form:

[a1 0   0   0   0   0]
[0  a1  0   0   0   0]
[0  0   a1  0   0   0]
[0  0   0   a2  0   0]
[0  0   0   0   a2  0]
[0  0   0   0   0  a2]

and b is a vector [b1 b1 b1 b2 b2 b2]

corresponding to the indices of i. That is, all entries in a and b will be ai and bi for pi
'''



def cost_function(x):
  quad_coefficients = [.1, .2, .3, .4]
  lin_coefficients = [5, 6, 7, 8]

  nodecount = len(quad_coefficients)
  timecount = len(timesteps)

  Q = np.zeros((96, 96))
  C = np.zeros((96))
  for t in range(timecount):
    for i in range(nodecount):
      for j in range(nodecount):
        indexval = t * ((nodecount ** 2) + (nodecount * 2)) + i * nodecount + j
        Q[indexval][indexval] = quad_coefficients[i]
        C[indexval] = lin_coefficients[i]

  return np.matmul(np.transpose(x),np.matmul(Q,x)+np.matmul(C,x))


# return results of optimization problem
results = opt.minimize(fun=cost_function,x0=initial_guess,constraints=constraint)


# printing the output
for i in range(96):
  print(timesteps[i // 24],'--',decision_variables[i % 24],':  ',np.round(results.x[i],2),'kW')

# DRAFT CODE - 4/1

import numpy as np
from scipy import optimize as opt


#3 node system
'''
                node 0
                /   \
               /     \
          node 1    node 2


'''

#------------------------------ FRONT MATTER
q = [0,1,1] #define reactive power starting at node 0, node 1, etc...



#cost function
cost = [1,1.2,.9];

#------------------------------ LINE FLOW CONSTRAINTS

#f (power flow constraints)
# creating the W matrix (see page 3 in lit)
W_bar = [[1,-1.,0.],[1,0.,1.]]
W = [[-1.,0.],[0.,1.]]
W_inv_T = np.transpose(np.linalg.inv(np.array(W)))
W_inv_T_cat = np.concatenate((np.zeros((2,1)),W_inv_T),axis=1)
W_total = np.concatenate((W_inv_T_cat,-1*W_inv_T_cat),axis=0)

# f bounds (first two values) and lower bounds (second two values)
f_bounds = [10,10,10,10]

#------------------------------ BALANCING CONSTRAINTS (ensuring Generation = Demand)

#ensuring power generation equals demand
A_eq_total = np.ones((1,3))
#demand
b_eq_total = 25.2;


#------------------------------ VOLTAGE CONSTRAINTS
#v (voltage constraints)

Fr = [[.1,0],[0,.2]] #diagonal matrix of line resistances
Fx = [[.1,0],[0,.2]] #diagonal matrix of line reactances

R = np.matmul(np.matmul(np.linalg.inv(W),Fr),np.transpose(np.linalg.inv(np.array(W))))
R = np.concatenate((np.zeros((2,1)),R),axis=1)
R_total = np.concatenate((R,-1*R),axis=0)
X = np.matmul(np.matmul(np.linalg.inv(W),Fx),np.transpose(np.linalg.inv(np.array(W))))
X = np.concatenate((np.zeros((2,1)),X),axis=1)
v_bar = np.matmul(X,q) + np.ones((1,2))
v_bar_double = np.concatenate((v_bar,v_bar),axis=1)
v_bounds = [2,2,2,2] - v_bar_double[0]





#------------------------------ REAL POWER CONSTRAINTS
#p constraints
#p upper and lower power bounds
p0 = (1,15)
p1 = (1,10)
p2 = (1,10)


A_ineq_total = np.concatenate((W_total,R_total),axis=0)
b_ineq_total = np.concatenate((f_bounds,v_bounds),axis=0)



output = opt.linprog(cost,
                     A_ub=A_ineq_total,
                     b_ub=b_ineq_total,
                     A_eq=A_eq_total,
                     b_eq=b_eq_total,
                     bounds=[p0,p1,p2])
print(output)

# DRAFT CODE - 4/1

import numpy as np
from scipy import optimize as opt


#cost function
cost = [1,1,1,1,1,1];


#pij balance matrix
'''
01
02
10
12
20
21
'''
balances = [[1,0,1,0,0,0],[0,1,0,0,1,0],[0,0,0,1,0,1]]
balance_outputs = np.zeros((1,3))


p01 = (None,None)
p02 = (None,None)
p10 = (12,12)
p12 = (0,0)
p20 = (10,10)
p21 = (0,0)


consolid = np.array([[1,1,0,0,0,0],[0,0,1,1,0,0],[0,0,0,0,1,1]])
p_limit = [100,100,100]


# creating the W matrix (see page 3 in lit)
W_bar = [[1,-1,0],[1,0,1]]
W = [[-1,0],[0,1]]
W_inv_T = np.transpose(np.linalg.inv(np.array(W)))
W_inv_T_cat = np.concatenate((np.zeros((2,1)),W_inv_T),axis=1)
W_total = np.concatenate((W_inv_T_cat,-1*W_inv_T_cat),axis=0)
W_total = np.matmul(W_total,consolid)

# f bounds (first two values) and lower bounds (second two values)
f_bounds = [100,100,100,100]


A_ineq_total = np.concatenate((W_total,consolid),axis=0)
A_ineq_total = np.concatenate((A_ineq_total,-1*consolid),axis=0)

b_ineq_total = np.concatenate((f_bounds,p_limit),axis=0)
b_ineq_total = np.concatenate((b_ineq_total,p_limit),axis=0)



output = opt.linprog(cost,
                     A_ub=A_ineq_total,
                     b_ub=b_ineq_total,
                     A_eq=balances,
                     b_eq=balance_outputs,
                     bounds=[p01,p02,p10,p12,p20,p21])

print(output)
