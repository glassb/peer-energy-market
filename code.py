# -*- coding: utf-8 -*-
"""EC500-Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1InvHioQipbEuSXscVzqDYbZeOQwQ3coh
"""

# 4/9

'''
                node 0
                /   \
               /     \
          node 1    node 2
          /
         /
      node 3


'''

import numpy as np
from scipy import optimize as opt

'''
00 01 02 03
10 11 12 13
20 21 22 23
30 31 32 33
'''

costs = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
initial_guess = np.zeros(16)
bounds = []
constraint = ({'type':'eq','fun': lambda x: sum(x) - sum(loads)},
              {'type':'eq','fun': lambda x: x[0]},
              {'type':'eq','fun': lambda x: x[5]},
              {'type':'eq','fun': lambda x: x[10]},
              {'type':'eq','fun': lambda x: x[15]},
              {'type':'eq','fun': lambda x: x[1]+x[5]},
              {'type':'eq','fun': lambda x: x[2]+x[9]}
              )


loads = [100,120,110]

def cost_function(x):
  Q = np.ones((16,16))
  C = np.ones((1,16))
  return np.matmul(np.transpose(x),np.matmul(Q,x)+np.matmul(C,x))


results = opt.minimize(fun=cost_function,x0=initial_guess,constraints=constraint)


print(results.x)

# DRAFT CODE - 4/1

import numpy as np
from scipy import optimize as opt


#3 node system
'''
                node 0
                /   \
               /     \
          node 1    node 2


'''

#------------------------------ FRONT MATTER
q = [0,1,1] #define reactive power starting at node 0, node 1, etc...



#cost function
cost = [1,1.2,.9];

#------------------------------ LINE FLOW CONSTRAINTS

#f (power flow constraints)
# creating the W matrix (see page 3 in lit)
W_bar = [[1,-1.,0.],[1,0.,1.]]
W = [[-1.,0.],[0.,1.]]
W_inv_T = np.transpose(np.linalg.inv(np.array(W)))
W_inv_T_cat = np.concatenate((np.zeros((2,1)),W_inv_T),axis=1)
W_total = np.concatenate((W_inv_T_cat,-1*W_inv_T_cat),axis=0)

# f bounds (first two values) and lower bounds (second two values)
f_bounds = [10,10,10,10]

#------------------------------ BALANCING CONSTRAINTS (ensuring Generation = Demand)

#ensuring power generation equals demand
A_eq_total = np.ones((1,3))
#demand
b_eq_total = 25.2;


#------------------------------ VOLTAGE CONSTRAINTS
#v (voltage constraints)

Fr = [[.1,0],[0,.2]] #diagonal matrix of line resistances
Fx = [[.1,0],[0,.2]] #diagonal matrix of line reactances

R = np.matmul(np.matmul(np.linalg.inv(W),Fr),np.transpose(np.linalg.inv(np.array(W))))
R = np.concatenate((np.zeros((2,1)),R),axis=1)
R_total = np.concatenate((R,-1*R),axis=0)
X = np.matmul(np.matmul(np.linalg.inv(W),Fx),np.transpose(np.linalg.inv(np.array(W))))
X = np.concatenate((np.zeros((2,1)),X),axis=1)
v_bar = np.matmul(X,q) + np.ones((1,2))
v_bar_double = np.concatenate((v_bar,v_bar),axis=1)
v_bounds = [2,2,2,2] - v_bar_double[0]





#------------------------------ REAL POWER CONSTRAINTS
#p constraints
#p upper and lower power bounds
p0 = (1,15)
p1 = (1,10)
p2 = (1,10)


A_ineq_total = np.concatenate((W_total,R_total),axis=0)
b_ineq_total = np.concatenate((f_bounds,v_bounds),axis=0)



output = opt.linprog(cost,
                     A_ub=A_ineq_total,
                     b_ub=b_ineq_total,
                     A_eq=A_eq_total,
                     b_eq=b_eq_total,
                     bounds=[p0,p1,p2])
print(output)

# DRAFT CODE - 4/1

import numpy as np
from scipy import optimize as opt


#cost function
cost = [1,1,1,1,1,1];


#pij balance matrix
'''
01
02
10
12
20
21
'''
balances = [[1,0,1,0,0,0],[0,1,0,0,1,0],[0,0,0,1,0,1]]
balance_outputs = np.zeros((1,3))


p01 = (None,None)
p02 = (None,None)
p10 = (12,12)
p12 = (0,0)
p20 = (10,10)
p21 = (0,0)


consolid = np.array([[1,1,0,0,0,0],[0,0,1,1,0,0],[0,0,0,0,1,1]])
p_limit = [100,100,100]


# creating the W matrix (see page 3 in lit)
W_bar = [[1,-1,0],[1,0,1]]
W = [[-1,0],[0,1]]
W_inv_T = np.transpose(np.linalg.inv(np.array(W)))
W_inv_T_cat = np.concatenate((np.zeros((2,1)),W_inv_T),axis=1)
W_total = np.concatenate((W_inv_T_cat,-1*W_inv_T_cat),axis=0)
W_total = np.matmul(W_total,consolid)

# f bounds (first two values) and lower bounds (second two values)
f_bounds = [100,100,100,100]


A_ineq_total = np.concatenate((W_total,consolid),axis=0)
A_ineq_total = np.concatenate((A_ineq_total,-1*consolid),axis=0)

b_ineq_total = np.concatenate((f_bounds,p_limit),axis=0)
b_ineq_total = np.concatenate((b_ineq_total,p_limit),axis=0)



output = opt.linprog(cost,
                     A_ub=A_ineq_total,
                     b_ub=b_ineq_total,
                     A_eq=balances,
                     b_eq=balance_outputs,
                     bounds=[p01,p02,p10,p12,p20,p21])

print(output)
